<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scrolling Tiled Map with Character Class</title>
  <style>
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border: 1px solid black;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script src="data.js"></script>
<script src="object.js"></script>
<script src="objects.js"></script>
<script src="tileset.js"></script>
<script>
  // ======= Tab pause / resume (visibility) handling =======
  let isPaused = false;
  let lastTime = null; // we use this as a rAF anchor (kept for clarity)

  // When tab becomes hidden -> pause updates.
  // When tab becomes visible -> resume and reset timing anchors to avoid huge deltas.
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Pause updates (we still keep the RAF loop running)
      isPaused = true;
    } else {
      // Resume: clear rAF anchor and reset per-object timers so no big dt on next frame
      isPaused = false;
      lastTime = null; // will be reinitialized on next RAF tick / update

      const now = performance.now();

      // Reset player animation timer (if present)
      try {
        if (typeof player !== 'undefined' && player) {
          if ('lastFrameTime' in player) player.lastFrameTime = now;
          if ('_lastTime' in player) player._lastTime = now;
        }
      } catch (e) {
        // defensive: ignore if player not ready yet
      }

      // Reset game objects' internal timers as best we can (defensive)
      if (window.objects && Array.isArray(window.objects)) {
        for (const obj of window.objects) {
          if (!obj) continue;
          if ('_lastTime' in obj) obj._lastTime = now;          // GameObject internal anchor
          if ('lastFrameTime' in obj) obj.lastFrameTime = now;  // other objects might use this
          // do NOT change pattern timers — they were not decremented while paused
        }
      }
    }
  });

  /* ====== Constants & Canvas ====== */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = 600;
  canvas.height = 400;
  
  /* ====== Offscreen map canvas ====== */
  const mapCanvas = document.createElement('canvas');
  const mapCtx = mapCanvas.getContext('2d');
  
  /* ====== Global object/obstacle containers (single source of truth) ====== */
  window.objects   = window.objects   || [];
  window.obstacles = window.obstacles || [];
  
  // If data.js created a `const obstacles = [...]` (it does), copy them into window.obstacles now:
  if (typeof obstacles !== 'undefined' && Array.isArray(obstacles)) {
    // copy only plain boxes (avoid overwriting objects that will be added later)
    for (const o of obstacles) {
      // avoid pushing the same plain box twice
      window.obstacles.push(o);
    }
  }
  
  /* ====== Tileset prep & loading ====== */
  /* (same as your existing logic) */
  const tilesetLimits = [];
  let runningTotal = 0;
  for (const ts of tilesets) {
    runningTotal += ts.cols * ts.rows;
    tilesetLimits.push(runningTotal);
  }
  
  const images = []; // loaded tileset images
  let tilesetsLoaded = 0;
  let characterLoaded = false;
  
  function cap(s){ return s.charAt(0).toUpperCase() + s.slice(1); }
  
  /* ====== DRAW A SINGLE TILE (by global index across all tilesets) ====== */
  function drawTile(globalIndex, x, y, context = ctx) {
    let tilesetIndex = 0;
    for (let i = 0; i < tilesetLimits.length; i++) {
      if (globalIndex < tilesetLimits[i]) {
        tilesetIndex = i;
        break;
      }
    }
    const startIdx = tilesetIndex === 0 ? 0 : tilesetLimits[tilesetIndex - 1];
    const localIndex = globalIndex - startIdx;
  
    const ts = tilesets[tilesetIndex];
    const sx = (localIndex % ts.cols) * TILE_SIZE;
    const sy = Math.floor(localIndex / ts.cols) * TILE_SIZE;
  
    context.drawImage(
      images[tilesetIndex],
      sx, sy, TILE_SIZE, TILE_SIZE,
      x, y, TILE_SIZE, TILE_SIZE
    );
  }
  
  /* ====== PRE-RENDER FULL MAP TO OFFSCREEN CANVAS ====== */
  function drawFullMapToCanvas() {
    mapCanvas.width = MAP_WIDTH * TILE_SIZE;
    mapCanvas.height = MAP_HEIGHT * TILE_SIZE;
  
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        const idx = y * MAP_WIDTH + x;
        const drawX = x * TILE_SIZE;
        const drawY = y * TILE_SIZE;
  
        if (baseMap[idx] != null) drawTile(baseMap[idx], drawX, drawY, mapCtx);
        if (overlayMap[idx] != null) drawTile(overlayMap[idx], drawX, drawY, mapCtx);
        // topMap is drawn after the player to allow "over" tiles
      }
    }
  }
  
  class Character {
    constructor(opts) {
      const {
        x, y, speed = 1.5,
        spriteSrc,
        spriteCols = 14,
        spriteRows = 4,
        frameDelay = 150,
        attackFrameDelay = 80,
        frames,
        // visual scale for drawing (optional). If you want to pass hitboxWidth = frameW * 2,
        // also pass scale: 2 so drawing and hitbox match.
        scale = 1,
        // explicit hitbox params (optional) - will be used if provided; otherwise computed on image load
        hitboxWidth = null,
        hitboxHeight = null,
        hitboxOffsetX = null,
        hitboxOffsetY = null,
        // fallback width/height used before image loads (not critical)
        width = 32,
        height = 32,
      } = opts;
  
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.speed = speed;
  
      // visual frame / drawing
      this.spriteCols = spriteCols;
      this.spriteRows = spriteRows;
      this.frameDelay = frameDelay;
      this.attackFrameDelay = attackFrameDelay;
      this.frames = frames;
  
      this.scale = scale;
  
      // store user-provided flags so we don't overwrite explicit hitbox choices
      this._userHitboxWidth  = (hitboxWidth  !== null && typeof hitboxWidth  !== 'undefined');
      this._userHitboxHeight = (hitboxHeight !== null && typeof hitboxHeight !== 'undefined');
      this._userHitboxOX     = (hitboxOffsetX !== null && typeof hitboxOffsetX !== 'undefined');
      this._userHitboxOY     = (hitboxOffsetY !== null && typeof hitboxOffsetY !== 'undefined');
  
      // pre-populate (may be overwritten/filled on image load if not provided)
      this.hitboxWidth  = hitboxWidth;
      this.hitboxHeight = hitboxHeight;
      this.hitboxOffsetX = hitboxOffsetX ?? 0;
      this.hitboxOffsetY = hitboxOffsetY ?? 0;
  
      // drawing defaults until image loads
      this.width  = width;
      this.height = height;
  
      this.direction = 'down';
      this.state = 'idle';
      this.moving = false;
  
      this.frameIndex = 0;
      this.lastFrameTime = 0;
  
      // Input gating for one-shot attack while holding Space
      this.attackHeld = false;
  
      // Image & frame sizes (calculated on load)
      this.image = new Image();
      this.image.onload = () => {
        // compute per-frame dimensions from the sprite sheet
        const frameW = this.image.naturalWidth / this.spriteCols;
        const frameH = this.image.naturalHeight / this.spriteRows;
        this.frameWidth = frameW;
        this.frameHeight = frameH;
  
        // drawn size (accounts for scale)
        this.drawWidth  = Math.round(frameW * this.scale);
        this.drawHeight = Math.round(frameH * this.scale);
  
        // if user didn't pass explicit hitbox dimensions, pick sane defaults:
        // - width: frame width * scale (so hitbox covers drawn sprite width) OR tile width
        // - height: prefer TILE_SIZE footprint (if defined) otherwise frameH * scale
        if (!this._userHitboxWidth) {
          // default to drawn width (frameW * scale) — this mirrors GameObject convention
          this.hitboxWidth = Math.round(frameW * this.scale);
        }
        if (!this._userHitboxHeight) {
          // prefer bottom-footprint equal to TILE_SIZE when available (common for tile games),
          // otherwise use drawn height
          if (typeof TILE_SIZE !== 'undefined') {
            this.hitboxHeight = TILE_SIZE;
          } else {
            this.hitboxHeight = Math.round(frameH * this.scale);
          }
        }
  
        // offsets: if not provided, center horizontally and anchor to the bottom
        if (!this._userHitboxOX) {
          this.hitboxOffsetX = Math.round((frameW * this.scale - this.hitboxWidth) / 2);
        }
        if (!this._userHitboxOY) {
          this.hitboxOffsetY = Math.round(frameH * this.scale - this.hitboxHeight);
        }
  
        // ensure the engine's width/height (used for depth sorting) reflect feet/hitbox height
        this.width  = this.hitboxWidth;
        this.height = this.hitboxHeight;
  
        // mark character image ready and start game if other assets are ready
        characterLoaded = true;
        startIfReady();
      };
      this.image.src = spriteSrc;
    }
  
    // Hitbox API to mirror GameObject
    getHitboxAt(x = this.x, y = this.y) {
      return {
        x: x + this.hitboxOffsetX,
        y: y + this.hitboxOffsetY,
        width: this.hitboxWidth,
        height: this.hitboxHeight,
      };
    }
    getHitbox() { return this.getHitboxAt(); }
  
    handleInput(keys, lastKey) {
      // Can't start moving while attack animation still playing
      if (this.state === 'attacking' && this.frameIndex < this.frames['attack' + cap(this.direction)].length) {
        this.vx = 0; this.vy = 0; this.moving = false;
        return;
      }
  
      const wasMoving = this.moving;
      this.vx = 0;
      this.vy = 0;
      this.moving = false;
  
      if (keys['w'] && lastKey === 'w') {
        this.vy = -this.speed;
        this.direction = 'up';
        this.moving = true;
      }
      if (keys['s'] && lastKey === 's') {
        this.vy = this.speed;
        this.direction = 'down';
        this.moving = true;
      }
      if (keys['a'] && lastKey === 'a') {
        this.vx = -this.speed;
        this.direction = 'left';
        this.moving = true;
      }
      if (keys['d'] && lastKey === 'd') {
        this.vx = this.speed;
        this.direction = 'right';
        this.moving = true;
      }
  
      if (this.moving && !wasMoving) {
        this.lastFrameTime = performance.now();
        this.state = 'walking';
      } else if (!this.moving && this.state !== 'attacking') {
        this.state = 'idle';
      }
    }
  
    startAttack() {
      if (this.state !== 'attacking') {
        this.state = 'attacking';
        this.frameIndex = 0;
        this.lastFrameTime = performance.now();
        this.vx = 0;
        this.vy = 0;
        this.moving = false;
      }
    }
  
    update(time, keys) {
      // Animation selection (same as before)
      let frames;
      if (this.state === 'attacking') {
        frames = this.frames['attack' + cap(this.direction)];
      } else if (this.moving || this.state === 'walking') {
        frames = this.frames[this.direction];
      } else {
        frames = this.frames['idle' + cap(this.direction)];
      }
  
      const delay = (this.state === 'attacking')
        ? this.attackFrameDelay
        : (this.moving ? this.frameDelay : this.frameDelay * 3);
  
      if ((this.moving || this.state === 'attacking' || this.state === 'idle') &&
          time - this.lastFrameTime > delay) {
  
        this.lastFrameTime = time;
  
        if (this.state === 'attacking') {
          this.frameIndex++;
          if (this.frameIndex >= frames.length) {
            // Finish attack
            this.frameIndex = 0;
            if (keys['w'] || keys['a'] || keys['s'] || keys['d']) {
              this.state = 'walking';
              this.handleInput(keys, lastKey); // reapply movement after attack
            } else {
              this.state = 'idle';
            }
          }
        } else {
          this.frameIndex = (this.frameIndex + 1) % frames.length;
        }
      }
    }
  
    draw(ctx) {
      if (!this.image || !this.image.complete) return;
  
      const frameW = this.image.naturalWidth / this.spriteCols;
      const frameH = this.image.naturalHeight / this.spriteRows;
  
      let frames;
      if (this.state === 'attacking') {
        frames = this.frames['attack' + cap(this.direction)];
      } else if (this.moving || this.state === 'walking') {
        frames = this.frames[this.direction];
      } else {
        frames = this.frames['idle' + cap(this.direction)];
      }
  
      const tileIndex = frames[this.frameIndex % frames.length];
      const sx = (tileIndex % this.spriteCols) * frameW;
      const sy = Math.floor(tileIndex / this.spriteCols) * frameH;
  
      // draw scaled if scale != 1
      const dw = Math.round(frameW * this.scale);
      const dh = Math.round(frameH * this.scale);
  
      ctx.drawImage(
        this.image,
        sx, sy, frameW, frameH,
        canvas.width / 2 - dw / 2,
        canvas.height / 2 - dh / 2,
        dw, dh
      );
    }
  }  

  /* ====== Load tileset images ====== */
  tilesets.forEach((tileset, i) => {
    const img = new Image();
    img.onload = () => {
      images[i] = img;
      tilesetsLoaded++;
      startIfReady();
    };
    img.src = tileset.src;
  });
  
  /* ====== Collision helper (unchanged) ====== */
  function isColliding(r1, r2) {
    return (
      r1.x < r2.x + r2.width &&
      r1.x + r1.width > r2.x &&
      r1.y < r2.y + r2.height &&
      r1.y + r1.height > r2.y
    );
  }
  
  const player = new Character({
    x: 24 * TILE_SIZE,
    y: 12 * TILE_SIZE,
    speed: 3,
    spriteSrc: 'mc-2.png',
    spriteCols: 14,
    spriteRows: 4,
    frames: {
      down: [52, 53, 54, 55],
      left: [10, 11, 12, 13],
      right: [24, 25, 26, 27],
      up: [38, 39, 40, 41],
      idleDown: [42, 43, 44, 45],
      idleLeft: [0, 1, 2, 3],
      idleRight: [14, 15, 16, 17],
      idleUp: [28, 29, 30, 31],
      attackDown: [46, 47, 48, 49, 50, 51],
      attackLeft: [4, 5, 6, 7, 8, 9],
      attackRight: [18, 19, 20, 21, 22, 23],
      attackUp: [32, 33, 34, 35, 36, 37]
    },
    scale: 1,
    hitboxWidth: 32,
    hitboxHeight: 20,
    hitboxOffsetX: 0,
    hitboxOffsetY: 15
  });
  
  // Make sure the player object is visible to object collision checks:
  if (!window.obstacles.includes(player)) window.obstacles.push(player);
  
  /* ====== Start when assets ready ====== */
  function startIfReady() {
    if (tilesetsLoaded === tilesets.length && characterLoaded) {
      drawFullMapToCanvas();
      requestAnimationFrame(gameLoop);
    }
  }
  
  /* ====== Draw obstacles (debug) ====== */
  function drawObstacles(ctx, offsetX, offsetY) {
    ctx.fillStyle = "rgba(255, 0, 0, 0.4)"; // other obstacles
    if (window.obstacles && Array.isArray(window.obstacles)) {
      for (const obs of window.obstacles) {
        if (!obs || obs === player) continue; // skip player here
        const box = (typeof obs.getHitbox === 'function') ? obs.getHitbox() : obs;
        ctx.fillRect(box.x - offsetX, box.y - offsetY, box.width, box.height);
      }
    }
  
    ctx.fillStyle = "rgba(0, 0, 255, 0.3)"; // player
    const pbox = player.getHitbox();
    ctx.fillRect(pbox.x - offsetX, pbox.y - offsetY, pbox.width, pbox.height);/**/
  }
  
  /* ====== Draw scene ====== */
  function drawScene(time) {
    let offsetX = player.x - canvas.width / 2 + TILE_SIZE / 2;
    let offsetY = player.y - canvas.height / 2 + TILE_SIZE / 2;
  
    offsetX = Math.max(0, Math.min(offsetX, MAP_WIDTH * TILE_SIZE - canvas.width));
    offsetY = Math.max(0, Math.min(offsetY, MAP_HEIGHT * TILE_SIZE - canvas.height));
  
    ctx.drawImage(
      mapCanvas,
      offsetX, offsetY, canvas.width, canvas.height,
      0, 0, canvas.width, canvas.height
    );
  
    const allEntities = [...window.objects, player];
    allEntities.sort((a, b) => (a.y + a.height) - (b.y + b.height));
  
    allEntities.forEach(ent => {
      if (ent instanceof GameObject) ent.draw(ctx, offsetX, offsetY);
      else if (ent instanceof Character) ent.draw(ctx);
      else if (typeof ent.draw === 'function') ent.draw(ctx, offsetX, offsetY);
    });
  
    // top tiles
    for (let y = 0; y < MAP_HEIGHT; y++) {
      for (let x = 0; x < MAP_WIDTH; x++) {
        const idx = y * MAP_WIDTH + x;
        const tile = topMap[idx];
        if (tile == null) continue;
  
        const drawX = x * TILE_SIZE - offsetX;
        const drawY = y * TILE_SIZE - offsetY;
        if (drawX + TILE_SIZE < 0 || drawX > canvas.width || drawY + TILE_SIZE < 0 || drawY > canvas.height) continue;
  
        drawTile(tile, drawX, drawY, ctx);
      }
    }
  
    drawObstacles(ctx, offsetX, offsetY);
  }
  
  /* ====== Update Character Position with Collision ====== */
  function updateCharacterPosition(char) {
    // NOTE: char.vx and char.vy are expected to be per-frame in your current input model.
    // We keep that, and move by vx/vy directly (consistent with your earlier code).
    const nextX = char.x + char.vx;
    const nextY = char.y + char.vy;
  
    function getBox(obs) {
      return (typeof obs.getHitbox === 'function') ? obs.getHitbox() : obs;
    }
  
    // X movement
    const testX = char.getHitboxAt(nextX, char.y);
    let blockedX = false;
    if (window.obstacles && Array.isArray(window.obstacles)) {
      for (const obs of window.obstacles) {
        if (!obs || obs === char) continue;
        const other = getBox(obs);
        if (typeof isColliding === 'function' && isColliding(testX, other)) {
          blockedX = true;
          break;
        }
      }
    }
    if (!blockedX) char.x = nextX; else char.vx = 0;
  
    // Y movement
    const testY = char.getHitboxAt(char.x, nextY);
    let blockedY = false;
    if (window.obstacles && Array.isArray(window.obstacles)) {
      for (const obs of window.obstacles) {
        if (!obs || obs === char) continue;
        const other = getBox(obs);
        if (typeof isColliding === 'function' && isColliding(testY, other)) {
          blockedY = true;
          break;
        }
      }
    }
    if (!blockedY) char.y = nextY; else char.vy = 0;
  }
  
  function gameLoop(time) {
    // If paused, skip updates/draw but keep RAF running so we can resume correctly.
    if (isPaused) {
      requestAnimationFrame(gameLoop);
      return;
    }
  
    // normal frame work (unchanged)
    ctx.fillStyle = '#9bd4c3';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    // 1) player movement & animation
    updateCharacterPosition(player);
    player.update(time, keys);
  
    // 2) objects (time-based animations and AI)
    window.objects.forEach(obj => { if (typeof obj.update === 'function') obj.update(time); });
  
    // 3) draw scene
    drawScene(time);
  
    requestAnimationFrame(gameLoop);
  }
  
  /* ====== Input handling (WASD + Space) ====== */
  const keys = {};
  let lastKey = '';
  
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.key === ' ') {
      if (!player.attackHeld) {
        player.attackHeld = true;
        player.startAttack();
      }
      return;
    }
  
    keys[e.key] = true;
    lastKey = e.key;
    player.handleInput(keys, lastKey);
  });
  
  document.addEventListener('keyup', (e) => {
    keys[e.key] = false;
    if (e.code === 'Space' || e.key === ' ') player.attackHeld = false;
    player.handleInput(keys, lastKey);
  });
  </script>
  
</body>
</html>
